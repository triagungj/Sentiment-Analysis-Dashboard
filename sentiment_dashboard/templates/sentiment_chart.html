<!DOCTYPE html>
<html>
  <head>
    <title>Sentiment Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
      .month-filter {
        margin-bottom: 20px;
      }
      .month-filter button {
        margin-right: 8px;
        padding: 6px 16px;
        font-size: 15px;
        border-radius: 4px;
        border: 1px solid #ccc;
        background: #f8f9fa;
        cursor: pointer;
      }
      .month-filter button.active {
        background: #007bff;
        color: #fff;
        border-color: #007bff;
      }

      /* Drag-scroll removed */
      .chart-container {
        overflow-x: auto;
        width: 100%;
        min-height: 70vh;
      }

      #sentimentChart {
        height: 400px;
      }

      /* News list */
      .news-section {
        margin-top: 24px;
      }
      .news-item {
        display: flex;
        gap: 12px;
        padding: 12px 0;
        border-bottom: 1px solid #eee;
        align-items: flex-start;
      }
      .thumb {
        flex: 0 0 72px;
        width: 72px;
        height: 72px;
        border-radius: 8px;
        overflow: hidden;
        background: #f2f2f2;
        border: 1px solid #e9ecef;
      }
      .thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .news-content {
        flex: 1;
        min-width: 0;
      }
      .news-item h4 {
        margin: 0 0 4px 0;
        font-size: 16px;
        line-height: 1.3;
      }
      .news-item a {
        text-decoration: none;
        color: #0d6efd;
      }
      .news-item a:hover {
        text-decoration: underline;
      }
      .news-meta {
        font-size: 12px;
        color: #6c757d;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* Badge base */
      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 11px;
        border: 1px solid #ddd;
        margin-left: 6px;
        text-transform: capitalize;
      }
      /* Sentiment colors */
      .badge.sentiment-positive {
        background: #153adf;
        color: #fff;
        border-color: #28a745;
      }
      .badge.sentiment-neutral {
        background: #ffc107;
        color: #000;
        border-color: #ffc107;
      }
      .badge.sentiment-negative {
        background: #dc3545;
        color: #fff;
        border-color: #dc3545;
      }
      .badge.sentiment-unknown {
        background: #e9ecef;
        color: #495057;
        border-color: #ced4da;
      }

      .load-more {
        margin: 12px 0 0 0;
        padding: 8px 14px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background: #fff;
        cursor: pointer;
      }
      .empty {
        color: #6c757d;
        font-style: italic;
        margin-top: 6px;
      }
      .btn-primary {
        margin: 0 0 32px;
        padding: 8px 14px;
        border: 1px solid #2563eb;
        background: #ffffff;
        color: #2563eb;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      }

      /* Dialog base */
      dialog {
        padding: 0;
        border: none;
        border-radius: 10px;
        width: min(720px, 92vw);
        max-width: 720px;
        box-shadow: 0 10px 35px rgba(0, 0, 0, 0.2);
      }

      /* Backdrop blur/dim */
      dialog::backdrop {
        background: rgba(0, 0, 0, 0.35);
        backdrop-filter: blur(2px);
      }

      .dialog-surface {
        background: #fff;
        border-radius: 10px;
        overflow: hidden;
      }

      .dialog-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 16px;
        border-bottom: 1px solid #e5e7eb;
      }

      .dialog-close {
        background: transparent;
        border: none;
        font-size: 20px;
        line-height: 1;
        cursor: pointer;
        padding: 4px 8px;
        color: #6b7280;
      }

      /* Predict card (same as before; keep or tweak) */
      .predict-card {
        padding: 16px;
        background: #fff;
      }
      .predict-card textarea {
        width: 100%;
        min-height: 110px;
        padding: 10px 12px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 14px;
        resize: vertical;
        box-sizing: border-box;
      }
      .predict-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 10px;
      }
      .predict-actions button {
        padding: 8px 14px;
        border: 1px solid #2563eb;
        background: #2563eb;
        color: #fff;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      }
      .predict-actions button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .predict-status {
        font-size: 13px;
        color: #6b7280;
      }
      .predict-result {
        margin-top: 12px;
        display: none;
        align-items: center;
        gap: 10px;
      }
      .pill {
        display: inline-block;
        padding: 6px 10px;
        border-radius: 999px;
        font-weight: 600;
        font-size: 13px;
        color: #fff;
      }
      .pill-positive {
        background: #16a34a;
      }
      .pill-neutral {
        background: #6b7280;
      }
      .pill-negative {
        background: #dc2626;
      }
      .score {
        font-size: 13px;
        color: #111827;
      }
      .predict-error {
        margin-top: 10px;
        color: #dc2626;
        font-size: 13px;
        display: none;
      }

      /* Screen-reader only helper (if you don't already have one) */
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <h2>Stock News Sentiment Analysis - CNBC Indonesia</h2>

    <!-- Trigger button - place this under your page title or toolbar -->
    <button id="openPredictDialogBtn" class="btn-primary">
      Try Predict Sentiment
    </button>

    <!-- Sentiment Predictor Dialog -->
    <dialog id="predictDialog" aria-labelledby="predictDialogTitle">
      <div class="dialog-surface">
        <div class="dialog-header">
          <h3 id="predictDialogTitle">Predict Sentiment</h3>
          <button
            type="button"
            id="closePredictDialogBtn"
            class="dialog-close"
            aria-label="Close"
          >
            ×
          </button>
        </div>

        <!-- —— The original Predict Sentiment card goes here —— -->
        <div class="predict-card">
          <form id="predictForm">
            <label for="predictText" class="sr-only">Text to analyze</label>
            <textarea
              id="predictText"
              placeholder="Type a headline or sentence..."
            ></textarea>
            <div class="predict-actions">
              <button id="predictBtn" type="submit">Predict</button>
              <span id="predictStatus" class="predict-status"></span>
            </div>
          </form>

          <div id="predictResult" class="predict-result">
            <span id="predictLabel" class="pill pill-neutral">NEUTRAL</span>
            <span id="predictScore" class="score">score: —</span>
          </div>

          <div id="predictError" class="predict-error"></div>
        </div>
      </div>
    </dialog>

    <div class="month-filter" id="monthFilter"></div>

    <div class="chart-container">
      <canvas id="sentimentChart" width="1600" height="400"></canvas>
    </div>

    <!-- News list -->
    <div class="news-section">
      <h3 id="newsTitle" style="margin-bottom: 8px">Latest News</h3>
      <div id="newsList"></div>
      <button id="loadMoreBtn" class="load-more" style="display: none">
        Load more
      </button>
    </div>

    <script>
      let chartInstance = null;
      let allData = [];
      let months = [];

      // Pagination & safety
      let currentMonth = null; // null = "All"
      let nextPageUrl = null;
      let isLoading = false;
      const visitedNext = new Set();
      let inFlight = null; // AbortController

      // Placeholder image
      const PLACEHOLDER_SVG =
        "data:image/svg+xml;utf8," +
        encodeURIComponent(
          `<svg xmlns="http://www.w3.org/2000/svg" width="72" height="72">
            <rect width="100%" height="100%" fill="#f2f2f2"/>
            <path d="M10 52 L28 34 L40 46 L52 34 L62 44 L62 62 L10 62 Z" fill="#e0e0e0"/>
            <circle cx="22" cy="22" r="8" fill="#e5e5e5"/>
          </svg>`
        );

      // --- helpers ---
      function sortByDateAsc(arr) {
        return arr.slice().sort((a, b) => new Date(a.date) - new Date(b.date));
      }

      // --- vertical hover line plugin for tooltip alignment ---
      const vlineHoverPlugin = {
        id: "vlineHover",
        afterDatasetsDraw(chart) {
          const idx = chart.$hoverIndex;
          if (idx == null) return;
          const {
            ctx,
            chartArea: { top, bottom },
            scales: { x },
          } = chart;
          const xPos = x.getPixelForValue(idx);
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(xPos, top);
          ctx.lineTo(xPos, bottom);
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 3]);
          ctx.strokeStyle = "#adb5bd";
          ctx.stroke();
          ctx.restore();
        },
      };
      if (window.Chart) Chart.register(vlineHoverPlugin);

      // Show tooltip when pointer is aligned with an X tick/label (any Y)
      function enableAxisHoverTooltip(chart) {
        const canvas = chart.canvas;
        const xScale = chart.scales.x;

        canvas.onmousemove = (e) => {
          if (!xScale) return;
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;

          let idx = xScale.getValueForPixel(x);
          if (idx == null || Number.isNaN(idx)) return;

          idx = Math.round(idx);
          idx = Math.max(0, Math.min(idx, chart.data.labels.length - 1));

          const elements = chart.data.datasets.map((_, di) => ({
            datasetIndex: di,
            index: idx,
          }));

          const vp = {
            x: xScale.getPixelForValue(idx),
            y: chart.scales.y?.top ?? chart.chartArea.top,
          };

          chart.setActiveElements(elements);
          chart.tooltip.setActiveElements(elements, vp);
          chart.$hoverIndex = idx;
          chart.update("none");
        };

        canvas.onmouseleave = () => {
          chart.setActiveElements([]);
          chart.tooltip.setActiveElements([], { x: 0, y: 0 });
          chart.$hoverIndex = null;
          chart.update("none");
        };
      }

      // --- chart ---
      function renderChart(filteredData, monthLabel) {
        // Ensure chronological order so NEWEST is on the RIGHT
        const sorted = sortByDateAsc(filteredData);

        const labels = sorted.map((item) => item.date);
        const positive = sorted.map((item) => item.positive);
        const neutral = sorted.map((item) => item.neutral);
        const negative = sorted.map((item) => item.negative);

        // dynamic width
        const chartCanvas = document.getElementById("sentimentChart");
        chartCanvas.width = Math.max(1600, labels.length * 20);

        const ctx = chartCanvas.getContext("2d");
        if (chartInstance) chartInstance.destroy();
        chartInstance = new Chart(ctx, {
          type: "line",
          data: {
            labels,
            datasets: [
              {
                label: "Positive",
                data: positive,
                borderColor: "#0072B2",
                backgroundColor: "rgba(0,114,178,0.2)",
                fill: false,
                tension: 0.3,
                pointRadius: 2,
              },
              {
                label: "Neutral",
                data: neutral,
                borderColor: "#E69F00",
                backgroundColor: "rgba(230,159,0,0.2)",
                fill: false,
                tension: 0.3,
                pointRadius: 2,
              },
              {
                label: "Negative",
                data: negative,
                borderColor: "#009E73",
                backgroundColor: "rgba(0,158,115,0.2)",
                fill: false,
                tension: 0.3,
                pointRadius: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: "index", intersect: false, axis: "x" },
            plugins: {
              legend: {
                labels: {
                  color: "#343a40",
                  font: {
                    size: 16,
                    family: "Helvetica Neue, Arial, sans-serif",
                    weight: "bold",
                  },
                },
              },
              title: {
                display: true,
                text: monthLabel
                  ? `Sentiment for ${monthLabel}`
                  : "Sentiment Statistics Per Month",
                font: { size: 18 },
              },
              zoom: {
                pan: { enabled: false, mode: "x" },
                zoom: {
                  wheel: { enabled: true, modifierKey: "ctrl" },
                  pinch: { enabled: true },
                  mode: "x",
                },
                limits: { x: { min: 0, max: labels.length - 1 } },
              },
              tooltip: { enabled: true },
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: "Date",
                  color: "#343a40",
                  font: { size: 14 },
                },
                ticks: { autoSkip: false, maxRotation: 90, minRotation: 45 },
              },
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Count",
                  color: "#343a40",
                  font: { size: 14 },
                },
              },
            },
          },
        });

        // enable tooltip-on-label behavior + vertical hover line
        enableAxisHoverTooltip(chartInstance);

        // focus latest month range (except weekly-all scenario)
        if (labels.length > 0 && monthLabel !== "All Months (Weekly)") {
          const latestMonth = labels[labels.length - 1].slice(0, 7);
          const startIdx = labels.findIndex(
            (l) => l.slice(0, 7) === latestMonth
          );
          chartInstance.options.scales.x.min = startIdx;
          chartInstance.options.scales.x.max = labels.length - 1;
          chartInstance.update();
        }
      }

      // --- news list (now with sentiment colors) ---
      function renderNewsList(items, append = false) {
        const list = document.getElementById("newsList");
        const loadMoreBtn = document.getElementById("loadMoreBtn");

        if (!append) list.innerHTML = "";

        if (append && (!items || items.length === 0)) {
          loadMoreBtn.style.display = "none";
          loadMoreBtn.disabled = true;
          loadMoreBtn.textContent = "No more";
          return;
        }
        if (!items || items.length === 0) {
          list.innerHTML = '<div class="empty">No news found.</div>';
          loadMoreBtn.style.display = "none";
          loadMoreBtn.disabled = true;
          loadMoreBtn.textContent = "No more";
          return;
        }

        const fragment = document.createDocumentFragment();
        items.forEach((n) => {
          const title = n.title || "Untitled";
          const url = n.url || n.link || "#";
          const date = n.published_at || n.created_at || n.date || "";
          const source = n.source?.name || n.source || "";
          const sentiment = n.sentiment || "";
          const imgSrc = n.image_link || PLACEHOLDER_SVG;

          // sentiment -> class
          const sKey = (sentiment || "").toLowerCase();
          const sentimentClass =
            sKey === "positive"
              ? "sentiment-positive"
              : sKey === "neutral"
              ? "sentiment-neutral"
              : sKey === "negative"
              ? "sentiment-negative"
              : "sentiment-unknown";

          const item = document.createElement("div");
          item.className = "news-item";
          item.innerHTML = `
            <div class="thumb">
              <img loading="lazy" src="${imgSrc}" alt=""
                   onerror="this.onerror=null;this.src='${PLACEHOLDER_SVG}';">
            </div>
            <div class="news-content">
              <h4><a href="${url}" target="_blank" rel="noopener noreferrer">${title}</a></h4>
              <div class="news-meta">
                <span>${date ? new Date(date).toLocaleString() : ""}</span>
                ${source ? ` • <span>${source}</span>` : ""}
                ${
                  sentiment
                    ? ` <span class="badge ${sentimentClass}">${sentiment}</span>`
                    : ""
                }
              </div>
            </div>
          `;
          fragment.appendChild(item);
        });
        list.appendChild(fragment);

        const hasNext = Boolean(nextPageUrl);
        loadMoreBtn.style.display = hasNext ? "inline-block" : "none";
        loadMoreBtn.disabled = !hasNext;
        loadMoreBtn.textContent = hasNext ? "Load more" : "No more";
      }

      // --- fetch helpers with loop protection ---
      function resetInFlight() {
        if (inFlight) inFlight.abort();
        inFlight = new AbortController();
        return inFlight.signal;
      }

      async function fetchPaged(url, append = false) {
        if (isLoading) return;
        if (url && visitedNext.has(url)) {
          nextPageUrl = null;
          renderNewsList([], true);
          return;
        }

        isLoading = true;
        const loadMoreBtn = document.getElementById("loadMoreBtn");
        if (!append) visitedNext.clear();
        if (append) {
          loadMoreBtn.disabled = true;
          loadMoreBtn.textContent = "Loading…";
        }

        try {
          const res = await fetch(url, { signal: inFlight?.signal });
          if (!res.ok) throw new Error(await res.text());
          const data = await res.json();
          const items = Array.isArray(data) ? data : data.results ?? [];
          const nextUrl = Array.isArray(data) ? null : data.next || null;

          if (url) visitedNext.add(url);
          nextPageUrl = nextUrl;

          renderNewsList(items, append);
        } catch (err) {
          if (err.name !== "AbortError") {
            console.error("Fetch error:", err);
            nextPageUrl = null;
            if (append) renderNewsList([], true);
          }
        } finally {
          isLoading = false;
          if (nextPageUrl) {
            loadMoreBtn.disabled = false;
            loadMoreBtn.textContent = "Load more";
          } else {
            loadMoreBtn.disabled = true;
            loadMoreBtn.textContent = "No more";
          }
        }
      }

      async function fetchNewsByMonth(
        month,
        urlOverride = null,
        append = false
      ) {
        const signal = resetInFlight();
        const base = `/api/news/?month=${encodeURIComponent(month)}`;
        const url = urlOverride || base;
        inFlight.signal = signal;
        await fetchPaged(url, append);
      }

      async function fetchLatestNews(urlOverride = null, append = false) {
        const signal = resetInFlight();
        const base = `/api/news/`; // relies on newest-first backend ordering
        const url = urlOverride || base;
        inFlight.signal = signal;
        await fetchPaged(url, append);
      }

      // --- UI wiring ---
      function renderMonthButtons() {
        const filterDiv = document.getElementById("monthFilter");
        filterDiv.innerHTML = "";

        months.forEach((month) => {
          const btn = document.createElement("button");
          btn.textContent = month;
          btn.onclick = async () => {
            document
              .querySelectorAll(".month-filter button")
              .forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");

            const filtered = allData.filter((item) =>
              item.date.startsWith(month)
            );
            renderChart(filtered, month);

            currentMonth = month;
            document.getElementById(
              "newsTitle"
            ).textContent = `News — ${month}`;
            nextPageUrl = null;
            visitedNext.clear();
            await fetchNewsByMonth(month);
          };
          filterDiv.appendChild(btn);
        });

        // "All" button
        const allBtn = document.createElement("button");
        allBtn.textContent = "All";
        allBtn.classList.add("active");
        allBtn.onclick = async () => {
          document
            .querySelectorAll(".month-filter button")
            .forEach((b) => b.classList.remove("active"));
          allBtn.classList.add("active");

          const weekData = [];
          let lastWeekKey = null;
          const sortedAll = sortByDateAsc(allData);
          renderChart(sortedAll, "All Months");

          currentMonth = null;
          nextPageUrl = null;
          visitedNext.clear();
          document.getElementById("newsTitle").textContent = "Latest News";
          await fetchLatestNews();
        };
        filterDiv.insertBefore(allBtn, filterDiv.firstChild);
      }

      document
        .getElementById("loadMoreBtn")
        .addEventListener("click", async () => {
          if (!nextPageUrl || isLoading) return;
          if (currentMonth) {
            await fetchNewsByMonth(currentMonth, nextPageUrl, true);
          } else {
            await fetchLatestNews(nextPageUrl, true);
          }
        });

      // --- initial load ---
      fetch("/api/dashboard/sentiment-stats/")
        .then((response) => response.json())
        .then(async (data) => {
          allData = data.map((item) => ({ ...item, date: item.date }));
          months = [...new Set(data.map((item) => item.date.slice(0, 7)))];
          renderMonthButtons();

          renderChart(allData, "All Months");
          document.getElementById("newsTitle").textContent = "Latest News";
          await fetchLatestNews();
        });

      // —— Your existing constant; adjust if your API path differs ——
      const PREDICT_URL = "/api/predict/";

      // CSRF helper (Django docs)
      function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== "") {
          const cookies = document.cookie.split(";");
          for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === name + "=") {
              cookieValue = decodeURIComponent(
                cookie.substring(name.length + 1)
              );
              break;
            }
          }
        }
        return cookieValue;
      }
      const csrftoken = getCookie("csrftoken");

      // Dialog wiring
      const openBtn = document.getElementById("openPredictDialogBtn");
      const dialog = document.getElementById("predictDialog");
      const closeBtn = document.getElementById("closePredictDialogBtn");

      openBtn.addEventListener("click", () => {
        dialog.showModal();
        // focus textarea when opened
        setTimeout(() => document.getElementById("predictText")?.focus(), 0);
      });

      closeBtn.addEventListener("click", () => dialog.close());

      // Close on click outside (backdrop)
      dialog.addEventListener("click", (e) => {
        const rect = dialog.getBoundingClientRect();
        const inDialog =
          e.clientX >= rect.left &&
          e.clientX <= rect.right &&
          e.clientY >= rect.top &&
          e.clientY <= rect.bottom;
        if (!inDialog) dialog.close();
      });

      // ESC cancels by default; but we ensure no form submits close the dialog unexpectedly
      dialog.addEventListener("cancel", (e) => {
        e.preventDefault(); // keep consistent close behavior
        dialog.close();
      });

      // Predictor form behavior (same logic as before)
      const form = document.getElementById("predictForm");
      const textarea = document.getElementById("predictText");
      const btn = document.getElementById("predictBtn");
      const statusEl = document.getElementById("predictStatus");
      const resultEl = document.getElementById("predictResult");
      const labelEl = document.getElementById("predictLabel");
      const scoreEl = document.getElementById("predictScore");
      const errorEl = document.getElementById("predictError");

      function setBadge(label) {
        const l = (label || "").toLowerCase();
        labelEl.textContent = (label || "—").toUpperCase();
        labelEl.className =
          "pill " +
          (l === "positive"
            ? "pill-positive"
            : l === "negative"
            ? "pill-negative"
            : "pill-neutral");
      }

      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        errorEl.style.display = "none";
        resultEl.style.display = "none";

        const text = textarea.value.trim();
        if (!text) {
          errorEl.textContent = "Please enter some text.";
          errorEl.style.display = "block";
          return;
        }

        btn.disabled = true;
        statusEl.textContent = "Predicting…";

        try {
          const resp = await fetch(PREDICT_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": csrftoken,
            },
            body: JSON.stringify({ text }),
          });

          if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(
              err.detail || err.error || `Request failed (${resp.status})`
            );
          }

          const data = await resp.json();
          // Expect: { label: "positive|neutral|negative", score: 0..1 }
          setBadge(data.label);
          const score =
            typeof data.score === "number"
              ? data.score
              : data.prob ?? data.confidence;
          scoreEl.textContent =
            "score: " + (score != null ? score.toFixed(4) : "—");
          resultEl.style.display = "flex";
        } catch (err) {
          errorEl.textContent = err.message || "Prediction failed.";
          errorEl.style.display = "block";
        } finally {
          btn.disabled = false;
          statusEl.textContent = "";
        }
      });
    </script>
  </body>
</html>
